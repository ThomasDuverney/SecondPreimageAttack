#+Title: Crypto Engineering TP â€” Generic second preimage attacks on long messages for narrow-pipe Merkle-Damgard hash functions
#+Author: Barrois. F, Duverney. T
#+Date: [2018-11-13]
#+OPTIONS: H:3 toc:nil


#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage{svg}
#+LaTeX_HEADER: \usemintedstyle{lovelace}
#+LaTeX_HEADER: \usepackage[all]{tcolorbox}
#+LaTeX_HEADER: \usepackage{etoolbox}
#+LaTeX_HEADER: \BeforeBeginEnvironment{minted}{\begin{tcolorbox}[enhanced, colback=white, boxrule=0.1pt,sharp corners, drop fuzzy shadow southeast=black!15!white]}%
#+LaTeX_HEADER: \AfterEndEnvironment{minted}{\end{tcolorbox}}%
#+LaTeX_HEADER: \BeforeBeginEnvironment{verbatim}{\begin{tcolorbox}[enhanced, boxrule=0.1pt,sharp corners, drop fuzzy shadow southeast=black!15!white]}%
#+LaTeX_HEADER: \AfterEndEnvironment{verbatim}{\end{tcolorbox}}%

* Part one: Preparatory work

** Question 1

For this function, we based our implementation on the following representation:


#+CAPTION: SPECK round function
#+NAME: fig.speck
[[speck48_96.png]]

As the function takes as input a 48-bit message and a key of 96 bits, the values \alpha and \beta are respectively set to 8 and 3.
So S^{-\alpha} performs a circular shift of 8 bits to the right, thus it can be done using ROTL24_16() since this function shifts a value of 16 bits to the left, which is the same as shifting it of 8 bits to the right over 24bits.
Similarly, S^{\beta} proceeds to a circular shift of 3 bits to the left and is implemented via a call to ROTL24_3().

Besides, the only difficulty here lies in the order of the operations. According to the picture above, we firstly do the shift on p[1], then we perform the modular addition with p[0]. Afterwards, we xor p[1] to the key value associated to the current iteration, and finally p[0] is updated by the circular shift and the obtained value is xored to p[1].


** Question 2

The speck48_96_inv process only consists in performing almost the same operations in the reverse order.
There exists a few differences though:
  + Because we want to invert the ciphering process, we need to apply S^{-\beta} on c[0] so we call ROTL24_21() (21 being the complement of 3 to 24), and symmetrically, we use ROTL24_8() for S^{\alpha} on c[1].
  + As a modular addition is done during the ciphering, in the case where the value of the modulo was reached, computing the substraction from the cipher will not give back then original value. In order to bypass this case, we add the value of the modulo before computing the substraction so that in any case the obtained value for c[1] will be such that 0 <= c[1] < modulo.
  *Remark:* Actually, the value is stored in an unsigned integer so the potential negative values due to the modular operation would be arranged to the right range of values, but we left the addition with the modulo value as it would be useful in a general case with a different implementation.


** Question 3

The function cs48_dm takes a 64-bit h as input so we need to format it to use our cipher speck48_96.
We compute both halves of it by applying a 24-bit mask on the least significant part and by shifting of 24 bits and applying the same mask to the most significant part (here the mask is a security measure for the case where the two most significant bytes of h are non-zero). Then we call our cipher and reformat the result in one 64-bit variable before xoring it with h, according to the Davies-Meyer function:  
$\epsilon(m, h) \oplus h$



* Part two: The attack
